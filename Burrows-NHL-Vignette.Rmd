---
title: "Joshua Burrows Project 1"
output: rmarkdown::github_document
---

```{r Setup, include=FALSE}
library(assertthat)
library(knitr)
library(tidyverse)
library(rmarkdown)
library(httr)
library(jsonlite)
opts_chunk$set(echo = TRUE)
```

# Title 

Hi

```{r Get Records Table}
recBaseURL <- "https://records.nhl.com/site/api"

# Return the requested table from records API
getTable <- function(table){
  
  if(!is.string(table)){
    stop("Input must be a character string")
  }
  
  recFullURL <- paste0(recBaseURL, "/", table) 
  info <- recFullURL %>% GET() %>% content("text", encoding = "UTF-8") %>% fromJSON(flatten = "TRUE")
  info <- info[[1]] %>% as_tibble()
  
  return(info)
}
```


```{r Filter Records Table}
# filter info from requested records table by team name or team Id
filterTable <- function(table, nameName = NULL, idNumName = NULL, name = NULL, idNum = NULL){
  
  # If neither filter condition specified, return full table
  if((is.null(name) & is.null(idNum))){
    return(table)
  }
  
  if((is.null(nameName) & is.null(idNumName))){
    stop("in order to filter, either nameName or idNumName must be specified")
  } 
  
  # User should search by one condition at a time
  if((!is.null(name) & !is.null(idNum))){
    stop("search by either name or idNum, not both")
  }
  
  if((!is.null(name) & is.null(nameName))){
    stop("if name is specified, nameName must be specified")
  }
  
  if((!is.null(idNum) & is.null(idNumName))){
    stop("is idNum is specified, idNumName must be specified")
  }
  
  if(!is.null(name)){
    if(name == "all"){ 
        return(table)
    } else{
        team <- table %>% filter(table[[nameName]] == name)
        if(length(team[[nameName]]) == 0){
          stop("not a vaild team name")
        } else{
            return(team)
          }
      } 
  }
    
  if(!is.null(idNum)){
    if(idNum == "all"){
        return(table)
    } else{
        team <- table %>% filter(table[[idNumName]] == idNum)
        if(length(team[[idNumName]]) == 0){ 
          stop("Not a valid team idNum")
        } else{
            return(team)
          }
      } 
  } 

}

```

```{r Franchise Records}
# Get franchise info by name or idNum
franchise <- function(name = NULL, idNum = NULL){

  franchises <- getTable("franchise") 
  
  filterTable(franchises, nameName = "teamCommonName", idNumName = "id", name, idNum) 
  
}
franchise()
```

```{r Franchise Team Records}
# Return franchise team totals
teamTotals <- function(name = NULL, idNum = NULL){
  
  teamTotals <- getTable("franchise-team-totals") 
  
  filterTable(teamTotals, nameName = "teamName", idNumName = "franchiseId", name, idNum) 
  
} 
teamTotals()
```


```{r Season Records}
# Return season records for a given franchise
season <- function(name = NULL, idNum = NULL){
  
  seasonRecords <- getTable("franchise-season-records") 
  
  filterTable(seasonRecords, nameName = "franchiseName", idNumName = "franchiseId", name, idNum) 
} 
```


```{r Goalie Records}
# Return franchise goalie records 
goalie <- function(name = NULL, idNum = NULL){
  
  goalieRecords <- getTable("franchise-goalie-records")
  
  filterTable(goalieRecords, nameName = "franchiseName", idNumName = "franchiseId", name, idNum)
  
} 
```


```{r Skater Records}
skater <- function(name = NULL, idNum = NULL){
  
  skaterRecords <- getTable("franchise-skater-records") 
  
  filterTable(skaterRecords, nameName = "franchiseName", idNumName = "franchiseId", name, idNum) 
  
}
```

# Stats API 

```{r getStatsTable}
statsBaseURL <- "https://statsapi.web.nhl.com/api/v1/teams"

getStatsTable <- function(modifier = NULL, seasonId = NULL, idNum = NULL){
  
  # no modifier 
  if(is.null(modifier)){
    
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum requires appropriate modifier")
    }
    
    base <- statsBaseURL %>% GET() %>% content("text") %>% fromJSON(flatten = TRUE)
    base <- base[[2]] %>% as_tibble()
    return(base)
  }
    
  # MODIFIER 
  # team.roster 
  if(modifier == "team.roster"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier team.roster")
    }
    
    mod = "?expand=team.roster"
  } 
  
  # MODIFIER 
  # person.names 
  if(modifier == "person.names"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier person.names")
    }
    
    mod = "?expand=person.names" 
  }
  
  # MODIFIER 
  # team.schedule.next 
  if(modifier == "team.schedule.next"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier team.schedule.next")
    }
    
    mod = "?expand=team.schedule.next"
  } 
  
  # MODIFIER 
  # team.schedule.previous 
  if(modifier == "team.schedule.previous"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier team.schedule.previous")
    }
    
    mod = "?expand=team.schedule.previous"
  }
  
  # MODIFIER 
  # team.stats
  if(modifier == "team.stats"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier team.stats")
    }
    
    mod = "?expand=team.stats"
  }
  
  # MODIFIER 
  # team.roster&season
  if(modifier == "team.roster&season"){
    if(!is.null(idNum)){
      stop("search by idNum not compatible with modifier team.roster&season")
    }
    
    if(is.null(seasonId)){
      stop("team.roster&season modifier requires search by seasonId") 
    }
    
    if(nchar(seasonId) != 8){
      stop("seasonId must be of format 20142015")
    }
    
    mod = paste0("?expand=team.roster&season=", seasonId)
  }
  
  # MODIFIER 
  # teamId
  if(modifier == "teamId"){
    if(!is.null(seasonId)){
      stop("search by seasonId not compatible with modifier teamId")
    }
    
    if(!is.null(idNum)){
      idCheck <- strsplit(idNum, split = "")[[1]]
      for(i in idCheck){
        if((!(i %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9", "0", ",")))){
          stop("idNum must be of format 1,2,3")
        }
      }
    }
    
    mod = paste0("?teamId=", idNum)
  }
  
  # MODIFIER 
  # statsSingleSeasonPlayoffs 
  if(modifier == "statsSingleSeasonPlayoffs"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier statsSingleSeasonPlayoffs")
    }
    
    mod <- "?stats=statsSingleSeasonPlayoffs"
  }
  
  # create URL and return 
  statsFullURL <- paste0(statsBaseURL, "/", mod)
  
  full <- statsFullURL %>% GET() %>% content("text") %>% fromJSON(flatten = TRUE)
  full <- full[[2]] %>% as_tibble()
  
  return(full)
}
```


## Teams Endpoint

The teams endpoint of the NHL stats API has eight modifiers. Typically, including a modifier returns more detailed information about a particular topic. 

Most modified endpoints require "flattening". 

This is a long one, so check out the comments to keep your bearings. 

```{r Stats Endpoint}
teamStats <- function(modifier = NULL, seasonId = NULL, idNum = NULL){
  
  # if no modifier is present
  if(is.null(modifier)){
    base <- getStatsTable()
    return(base)
  }

  # MODIFIER 
  # team.roster
  if(modifier == "team.roster"){
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    
    # get col to be flattened 
    roster <- stats[["roster.roster"]] 
    
    # append team names to keep track of who plays for who
    for(i in 1:length(roster)){
      roster[[i]]$name <- stats[["name"]][[i]]
    }
    
    # flatten roster info
    roster <- do.call(rbind, roster)
    statsFlatten <- left_join(roster, stats, by = "name") %>% select(-c("roster.roster"))
    
    return(statsFlatten)
  } 
  
  # MODIFIER
  # person.names
  # appears to be the same as the unmodified endpoint 
  if(modifier == "person.names"){ 
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    return(stats) 
  } 
  
  # MODIFIER
  # team.schedule.next 
  if(modifier == "team.schedule.next"){
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum)
    
    # get col to be flattened 
    dates <- stats[["nextGameSchedule.dates"]]
    
    # create names column to track data by team
    # create list of teams that have a next game scheduled 
    datesNonNull <- list()
    for(i in 1:length(dates)){
      if(!is.null(dates[[i]])){
        dates[[i]]$name <- stats[["name"]][[i]]
        datesNonNull <- cbind(datesNonNull, dates[i])
      }
    }
    
    # flatten datesNonNull
    for(i in 1:length(datesNonNull)){
      datesNonNull[[i]] <- cbind(datesNonNull[[i]], datesNonNull[[i]][["games"]]) %>% select(-c("games")) 
      
      datesNonNull[[i]][["events"]] <- 
        datesNonNull[[i]][["events"]][[1]][1][[1]]
      
      datesNonNull[[i]][["matches"]] <- 
        datesNonNull[[i]][["matches"]][[1]][1][[1]]
    } 
    
    # Put dates info in one tibble 
    datesVert <- tibble() 
    for(i in 1:length(datesNonNull)){
      datesVert <- rbind(datesVert, datesNonNull[[i]]) 
    } 
    
    # join flattened data with full data set 
    schedule <- left_join(stats, datesVert, by = "name", suffix = c(".main", ".nextGame")) %>% select(-c("nextGameSchedule.dates"))
    
    return(schedule) 
  } 
  
  # MODIFIER
  # team.schedule.previous
  if(modifier == "team.schedule.previous"){
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    
    # grab col to flatten
    dates <- stats[["previousGameSchedule.dates"]]
    
    # create names column to track data by team
    # create list of teams that have a next game scheduled 
    datesNonNull <- list()
    for(i in 1:length(dates)){
      if(!is.null(dates[[i]])){
        dates[[i]]$name <- stats[["name"]][[i]]
        datesNonNull <- cbind(datesNonNull, dates[i])
      }
    }
    
    # flatten datesNonNull
    for(i in 1:length(datesNonNull)){
      datesNonNull[[i]] <- cbind(datesNonNull[[i]], datesNonNull[[i]][["games"]]) %>% select(-c("games")) 
      
      datesNonNull[[i]][["events"]] <- 
        datesNonNull[[i]][["events"]][[1]][1][[1]]
      
      datesNonNull[[i]][["matches"]] <- 
        datesNonNull[[i]][["matches"]][[1]][1][[1]]
    } 
    
    # create venue.id col where it doesn't exist 
    for(i in 1:length(datesNonNull)){
      if(is.null(datesNonNull[[i]][["venue.id"]])){
        datesNonNull[[i]][["venue.id"]] <- NA
      }
    }
    
    # put dates info in one tibble 
    datesVert <- tibble() 
    for(i in 1:length(datesNonNull)){
      datesVert <- rbind(datesVert, datesNonNull[[i]]) 
    } 
  
    # join flattened data with full data set 
    schedule <- left_join(stats, datesVert, by = "name", suffix = c(".main", ".previousGame")) %>% select(-c("previousGameSchedule.dates"))
    
    return(schedule) 
  } 
  
  # MODIFIER
  # team.stats
  if(modifier == "team.stats"){ 
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum)
    
    # create empty list to contain final results
    final <- list()
    
    # include data from the base endpoint 
    final$teamOverview <- stats %>% select(-c("teamStats"))
    
    # get col to flatten
    teamStats <- stats[["teamStats"]]
    
    # empty tibbles to contain flattened data 
    statsOverview <- tibble()
    statsValues <- tibble()
    statsRanks <- tibble()
    
    # flatten 
    for(i in 1:length(teamStats)){
      teamStats[[i]]$name <- stats[["name"]][[i]]
      
      statsOverview <- rbind(statsOverview, teamStats[[i]])
      
      statsValues <- rbind(statsValues, teamStats[[i]][["splits"]][[1]][1, ]) 
      
      statsRanks <- rbind(statsRanks, teamStats[[i]][["splits"]][[1]][2, ])
    }
    
    statsOverview <- statsOverview %>% select(-c("splits"))
    
    # values table should be numeric 
    for(i in 1:(ncol(statsValues) - 2)){
      statsValues[[i]] <- as.double(statsValues[[i]])
    }
    
    # fill in final list 
    final$statsOverview <- statsOverview
    final$statsValues <- statsValues
    final$statsRanks <- statsRanks
    
    return(final)
  } 
  
  # MODIFIER
  # team.roster&season
  if(modifier == "team.roster&season"){
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    
    # get col to flatten 
    roster <- stats[["roster.roster"]]
    
    # add team names to keep track of who plays for who 
    for(i in 1:length(roster)){
      roster[[i]]$name <- stats[["name"]][[i]]
    }
    
    # flatten 
    roster <- do.call(rbind, roster)
    
    # combine and return 
    statsFlatten <- left_join(roster, stats, by = "name") %>% select(-c("roster.roster"))
    
    return(statsFlatten)
  }
  
  # MODIFIER
  # teamId
  if(modifier == "teamId"){
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    
    return(stats) 
  }
  
  # MODIFIER
  # statsSingleSeasonPlayoffs
  # appears to be the same as the unmodified endpoint
  if(modifier == "statsSingleSeasonPlayoffs"){
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum)
    
    return(stats)
  }
  
  stop("modifier must be one of: team.roster, person.names, team.schedule.next, team.schedule.previous, team.stats, team.roster&season, teamId, statsSingleSeasonPlayoffs")
}

```


# Wrapper 

```{r Wrapper}
getNHL <- function(API, recTable = NULL, name = NULL, idNum = NULL, modifier = NULL, seasonId = NULL){
  
  if(!(API %in% c("records", "stats"))){
    return(warning("API must be either records or stats"))
  }
  
  if(API == "records"){
    
    if(recTable == "franchise"){
      tab <- franchise(name = name, idNum = idNum)
      return(tab)
    }
    
    if(recTable == "franchise-team-totals"){
      tab <- teamTotals(name = name, idNum = idNum)
      return(tab)
    }
    
    if(recTable == "franchise-season-records"){
      tab <- season(name = name, idNum = idNum)
      return(tab) 
    }
    
    if(recTable == "franchise-goalie-records"){
      tab <- goalie(name = name, idNum = idNum)
      return(tab) 
    }
    
    if(recTable == "franchise-skater-records"){
      tab <- skater(name = name, idNum = idNum)
      return(tab) 
    }
    
    stop("recTable must be one of: franchise, franchise-team-totals, franchise-season-records, franchise-goalie-records, franchise-skater-records")
  
  }
  
  if(API == "stats"){
   tab <- teamStats(modifier = modifier, seasonId = seasonId, idNum = idNum)
   return(tab)
  }
  
}

getNHL(API = "records", recTable = "franchise")
getNHL(API = "records", recTable = "franchise-team-totals")
getNHL(API = "records", recTable = "franchise-season-records") 
getNHL(API = "records", recTable = "franchise-goalie-records", idNum = 5)
getNHL(API = "records", recTable = "franchise-skater-records", name = "Dallas Stars")

getNHL(API = "stats")
getNHL(API = "stats", modifier = "team.roster")
getNHL(API = "stats", modifier = "person.names")
getNHL(API = "stats", modifier = "team.schedule.next")
getNHL(API = "stats", modifier = "team.schedule.previous")
getNHL(API = "stats", modifier = "team.stats")
getNHL(API = "stats", modifier = "team.roster&season", seasonId = "20192020")
getNHL(API = "stats", modifier = "teamId")

```

# Exploratory Data Anlaysis 

What are the characteristics of a winning team?

```{r Wins and Penalties}
totals <- getNHL(API = "records", recTable = "franchise-team-totals")
totalsRegular <- totals %>% filter(gameTypeId == 2)
totalsPost <- totals %>% filter(gameTypeId == 3)

totalsRegular <- totalsRegular %>% filter(gamesPlayed >= 500) %>% mutate(winPct = wins / gamesPlayed, penaltyAvg = penaltyMinutes / gamesPlayed)
totalsRegular

totalsPost <- totalsPost %>% filter(gamesPlayed >= 50) %>% mutate(winPct = wins / gamesPlayed, penaltyAvg = penaltyMinutes / gamesPlayed)
totalsPost

corRegular <- cor(totalsRegular$winPct, totalsRegular$penaltyAvg)

corPost <- cor(totalsPost$winPct, totalsPost$penaltyAvg)

ggplot(totalsRegular, aes(x = penaltyAvg, y = winPct)) + geom_point() + geom_smooth(method = lm, col = "red") + geom_text(x = 20, y = .5, label = paste0("Correlation = ", round(corRegular, 2))) + labs(title = "Wins and Penalty Minutes, Regular Season", x = "Average Penalty Minutes", y = "Win Percentage", caption = "Teams with at least 500 games")

ggplot(totalsPost, aes(x = penaltyAvg, y = winPct)) + geom_point() + geom_smooth(method = lm) + geom_text(x = 20, y = .55, label = paste0("Correlation = ", round(corPost, 2))) + labs(title = "Wins and Penalty Minutes, Post Season", x = "Average Penalty Minutes", y = "Win Percentage", caption = "Teams with at least 50 games")

```



```{r Wins and Goals}
totalsRegular[["teamName"]] %>% sort()


skaters <- getNHL(API = "records", recTable = "franchise-skater-records") 
skaters

skatersSmall <- skaters %>% filter(franchiseName %in% totalsRegular[["teamName"]], positionCode != "D", goals > 200) %>% rename("teamName" = "franchiseName") %>% select(c("teamName", "goals", "positionCode"))

skatersSmall



skatersTeamTotals <- inner_join(skatersSmall, totalsPost, by = "teamName")
skatersTeamTotals

ggplot(skatersTeamTotals, aes(x = goals, y = winPct, color = positionCode)) + geom_point()
```


```{r Diffs}
teamInfo <- getNHL(API = "stats", modifier = "team.stats")
values <- teamInfo[["statsValues"]]
values

teams <- getNHL(API = "stats")
teams

teamValues <- inner_join(teams, values, by = c("name" = "team.name"))
teamValues

teamValues <- teamValues %>% mutate(WLDiff = stat.wins - stat.losses, shotDiff = stat.shotsPerGame - stat.shotsAllowed)

positive <- function(x){
  if(x > 0){
    return("Winning Team")
  } else if(x == 0){
    return("50/50 Team")
    } else{
        return("Losing Team")
      }
}

positive <- Vectorize(positive)

teamValues <- teamValues %>% mutate(WLDiffIndicator = positive(WLDiff))

teamValues

table(teamValues$division.name, teamValues$WLDiffIndicator)
table(teamValues$conference.name, teamValues$WLDiffIndicator)

g <- ggplot(teamValues, aes(x = WLDiffIndicator))

g + geom_bar(aes(fill = division.name), position = "dodge") + labs(title = "Winning Teams by Division", x = "Record", y = "Count") + scale_fill_discrete(name = "Division")

g + geom_bar(aes(fill = conference.name), position = "dodge") + labs(title = "Winning Teams by Conference", x = "Record", y = "Count") + scale_fill_discrete(name = "Conference")

g2 <- ggplot(teamValues, aes(x = WLDiff, y = ..density..))
g2 + geom_histogram(bins = 10, fill = "lightblue") + geom_density(lwd = 2, color = "darkblue") + labs(title = "Win/Loss Differential", x = "Wins Minus Losses", y = "Density")

teamValues

ggplot(teamValues, aes(x = WLDiff, y = shotDiff, color = conference.name)) + geom_point() + labs(title = "Win/Loss Differential by Shots Taken/Allowed Differential", x = "Wins Minus Losses", y = "Shots Taken Minus Shots Allowed", color = "Conference")
```

```{r Tables}
teams
totalsRegular
totalsRegular <- totalsRegular %>% mutate(avgGoalsAgainst = goalsAgainst / gamesPlayed, avgGoalsFor = goalsFor / gamesPlayed)
totalsRegular

totalsRegularActive <- left_join(teams, totalsRegular, by = c("name" = "teamName"))
totalsRegularActive

totalsRegularActive %>% group_by(division.name) %>% summarize(divisionAvgGoalsAgainst = round(mean(avgGoalsAgainst), 3), divisionAvgGoalsFor = round(mean(avgGoalsFor), 3))

g3 <- ggplot(totalsRegularActive, aes(x = division.name))

g3 + geom_boxplot(aes(y = avgGoalsAgainst)) + labs(title = "Average Goals Against by Division", x = "Division", y = "Average Goals Against")

g3 + geom_boxplot(aes(y = avgGoalsFor)) + labs(title = "Average Goals For by Division", x = "Division", y = "Average Goals For")


divSum <- function(div){
  
  # Make sure input is correct type
  if(!is.string(div)){
    stop("Input must be a character string!") 
  } 
  
  # Get the numbers for the division in question
  splitz <- totalsRegularActive %>% filter(division.name == div) %>% select(c("pointPctg", "avgGoalsAgainst", "avgGoalsFor"))
  
  # Get the summary statistics 
  statz <- splitz %>% apply(MARGIN = 2, FUN = summary) %>% round(digits = 3)
  
  # Format pretty for printing 
  cap <- paste0(div, " Division")
  statz <- statz %>% kable(caption = cap)
  
  return(statz)
}

divSum("Atlantic")
divSum("Central")
divSum("Metropolitan")
divSum("Pacific")


```


















