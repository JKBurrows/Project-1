---
title: "Joshua Burrows Project 1"
output: rmarkdown::github_document
---

```{r Setup, include=FALSE}
library(assertthat)
library(knitr)
library(tidyverse)
library(rmarkdown)
library(httr)
library(jsonlite)
opts_chunk$set(echo = TRUE)
```

# Title 

Hi

```{r Get Records Table}
recBaseURL <- "https://records.nhl.com/site/api"

# Return the requested table from records API
getTable <- function(table){
  
  if(!is.string(table)){
    stop("Input must be a character string")
  }
  
  recFullURL <- paste0(recBaseURL, "/", table) 
  info <- recFullURL %>% GET() %>% content("text", encoding = "UTF-8") %>% fromJSON(flatten = "TRUE")
  info <- info[[1]] %>% as_tibble()
  
  return(info)
}
```


```{r Filter Records Table}
# filter info from requested records table by team name or team Id
filterTable <- function(table, nameName = NULL, idNumName = NULL, name = NULL, idNum = NULL){
  
  # If neither filter condition specified, return full table
  if((is.null(name) & is.null(idNum))){
    return(table)
  }
  
  if((is.null(nameName) & is.null(idNumName))){
    stop("in order to filter, either nameName or idNumName must be specified")
  } 
  
  # User should search by one condition at a time
  if((!is.null(name) & !is.null(idNum))){
    stop("search by either name or idNum, not both")
  }
  
  if((!is.null(name) & is.null(nameName))){
    stop("if name is specified, nameName must be specified")
  }
  
  if((!is.null(idNum) & is.null(idNumName))){
    stop("is idNum is specified, idNumName must be specified")
  }
  
  if(!is.null(name)){
    if(name == "all"){ 
        return(table)
    } else{
        team <- table %>% filter(table[[nameName]] == name)
        if(length(team[[nameName]]) == 0){
          stop("not a vaild team name")
        } else{
            return(team)
          }
      } 
  }
    
  if(!is.null(idNum)){
    if(idNum == "all"){
        return(table)
    } else{
        team <- table %>% filter(table[[idNumName]] == idNum)
        if(length(team[[idNumName]]) == 0){ 
          stop("Not a valid team idNum")
        } else{
            return(team)
          }
      } 
  } 

}

```

```{r Franchise Records}
# Get franchise info by name or idNum
franchise <- function(name = NULL, idNum = NULL){

  franchises <- getTable("franchise") 
  
  filterTable(franchises, nameName = "teamCommonName", idNumName = "id", name, idNum) 
  
}
franchise()
```

```{r Franchise Team Records}
# Return franchise team totals
teamTotals <- function(name = NULL, idNum = NULL){
  
  teamTotals <- getTable("franchise-team-totals") 
  
  filterTable(teamTotals, nameName = "teamName", idNumName = "franchiseId", name, idNum) 
  
} 
teamTotals()
```


```{r Season Records}
# Return season records for a given franchise
season <- function(name = NULL, idNum = NULL){
  
  seasonRecords <- getTable("franchise-season-records") 
  
  filterTable(seasonRecords, nameName = "franchiseName", idNumName = "franchiseId", name, idNum) 
} 
```


```{r Goalie Records}
# Return franchise goalie records 
goalie <- function(name = NULL, idNum = NULL){
  
  goalieRecords <- getTable("franchise-goalie-records")
  
  filterTable(goalieRecords, nameName = "franchiseName", idNumName = "franchiseId", name, idNum)
  
} 
```


```{r Skater Records}
skater <- function(name = NULL, idNum = NULL){
  
  skaterRecords <- getTable("franchise-skater-records") 
  
  filterTable(skaterRecords, nameName = "franchiseName", idNumName = "franchiseId", name, idNum) 
  
}
```

# Stats API 

```{r getStatsTable}
statsBaseURL <- "https://statsapi.web.nhl.com/api/v1/teams"

getStatsTable <- function(modifier = NULL, seasonId = NULL, idNum = NULL){
  
  if(is.null(modifier)){
    base <- statsBaseURL %>% GET() %>% content("text") %>% fromJSON(flatten = TRUE)
  base <- base[[2]] %>% as_tibble()
  return(base)
  }
    
  if(modifier == "team.roster"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier team.roster")
    }
    
    mod = "?expand=team.roster"
  } 
  
  if(modifier == "person.names"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier person.names")
    }
    
    mod = "?expand=person.names" 
  }
  
  if(modifier == "team.schedule.next"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier team.schedule.next")
    }
    
    mod = "?expand=team.schedule.next"
  } 
  
  if(modifier == "team.schedule.previous"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier team.schedule.previous")
    }
    
    mod = "?expand=team.schedule.previous"
  }
  
  if(modifier == "team.stats"){
    if((!is.null(seasonId) | !is.null(idNum))){
      stop("search by seasonId and/or idNum not compatible with modifier team.stats")
    }
    
    mod = "?expand=team.stats"
  }
  
  if(modifier == "team.roster&season"){
    if(!is.null(idNum)){
      stop("search by idNum not compatible with modifier team.roster&season")
    }
    
    mod = paste0("?expand=team.roster&season=", seasonId)
  }
  
  if(modifier == "teamId"){
    if(!is.null(seasonId)){
      stop("search by seasonId not compatible with modifier team.roster&season")
    }
    
    if(!is.null(idNum)){
      idCheck <- strsplit(idNum, split = "")[[1]]
      for(i in idCheck){
        if((!(i %in% c("1", "2", "3", "4", "5", "6", "7", "8", "9", "0", ",")))){
          stop("idNum must be of format 1,2,3")
        }
      }
    }
    
    mod = paste0("?teamId=", idNum)
  }
  
  statsFullURL <- paste0(statsBaseURL, "/", mod)
  
  full <- statsFullURL %>% GET() %>% content("text") %>% fromJSON(flatten = TRUE)
  full <- full[[2]] %>% as_tibble()
  
  return(full)
}
getStatsTable(modifier = "team.stats")[["teamStats"]][[1]]
```


## Teams Endpoint

The teams endpoint of the NHL stats API has eight modifiers. Typically, including a modifier returns more detailed information about a particular topic. 

Most modified endpoints require "flattening". 

```{r Stats Endpoint}
teamStats <- function(modifier = NULL, seasonId = NULL, idNum = NULL){
  
  # if no modifier is present
  if(is.null(modifier)){
    base <- getStatsTable()
    return(base)
  }

  # MODIFIER 
  # team.roster
  if(modifier == "team.roster"){
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    
    roster <- stats[["roster.roster"]] 
    
    for(i in 1:length(roster)){
      roster[[i]]$name <- stats[["name"]][[i]]
    }
    
    roster <- do.call(rbind, roster)
    statsFlatten <- left_join(roster, stats, by = "name") %>% select(-c("roster.roster"))
    return(statsFlatten)
  } 
  
  # MODIFIER
  # person.names
  # appears to be the same as the unmodified endpoint 
  if(modifier == "person.names"){ 
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    return(stats) 
  } 
  
  # MODIFIER
  # team.schedule.next 
  if(modifier == "team.schedule.next"){
    
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum)
    
    # Grab column that needs to be flattened 
    dates <- stats[["nextGameSchedule.dates"]]
    
    # Create names column to track data by team
    # Create list of teams that have a next game scheduled 
    datesNonNull <- list()
    for(i in 1:length(dates)){
      dates[[i]]$name <- stats[["name"]][[i]]
      if(length(dates[[i]]) > 1){
        datesNonNull <- cbind(datesNonNull, dates[i])
      }
    }
    
    # Flatten datesNonNull
    for(i in 1:length(datesNonNull)){
      datesNonNull[[i]] <- cbind(datesNonNull[[i]], datesNonNull[[i]][["games"]]) %>% select(-c("games")) 
      
      datesNonNull[[i]][["events"]] <- 
        datesNonNull[[i]][["events"]][[1]][1][[1]]
      
      datesNonNull[[i]][["matches"]] <- 
        datesNonNull[[4]][["matches"]][[1]][1][[1]]
    } 
    
    # Put dates info in one tibble 
    datesVert <- tibble() 
    for(i in 1:length(datesNonNull)){
      datesVert <- rbind(datesVert, datesNonNull[[i]]) 
    } 
    
    # Join flattened data with full data set 
    schedule <- left_join(stats, datesVert, by = "name") %>% select(-c("nextGameSchedule.dates"))
    # need to rename any cols? 
    
    return(schedule) 
  } 
  
  # MODIFIER
  # team.schedule.previous
  if(modifier == "team.schedule.previous"){
    
    # Have to type modifier here? 
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    
    # Grab col that needs to be flattened 
    dates <- stats[["previousGameSchedule.dates"]]
    
    # Create names column to track data by team
    # Create list of teams that have a next game scheduled 
    datesNonNull <- list()
    for(i in 1:length(dates)){
      dates[[i]]$name <- stats[["name"]][[i]]
      if(length(dates[[i]]) > 1){
        datesNonNull <- cbind(datesNonNull, dates[i])
      }
    }
    
    # Flatten datesNonNull
    for(i in 1:length(datesNonNull)){
      datesNonNull[[i]] <- cbind(datesNonNull[[i]], datesNonNull[[i]][["games"]]) %>% select(-c("games")) 
      
      datesNonNull[[i]][["events"]] <- 
        datesNonNull[[i]][["events"]][[1]][1][[1]]
      
      datesNonNull[[i]][["matches"]] <- 
        datesNonNull[[4]][["matches"]][[1]][1][[1]]
    } 
    
    # Create venue.id col where it doesn't exist 
    for(i in 1:length(datesNonNull)){
      if(is.null(datesNonNull[[i]][["venue.id"]])){
        datesNonNull[[i]][["venue.id"]] <- NA
      }
    }
    
    # Put dates info in one tibble 
    datesVert <- tibble() 
    for(i in 1:length(datesNonNull)){
      datesVert <- rbind(datesVert, datesNonNull[[i]]) 
    } 
  
    # Join flattened data with full data set 
    schedule <- left_join(stats, datesVert, by = "name") %>% select(-c("previousGameSchedule.dates"))
    # need to rename any cols? 
    
    return(schedule) 
  } 
  
  # MODIFIER
  # team.stats
  if(modifier == "team.stats"){ 
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum)
    
    statsFull <- tibble()
    for(i in stats[["name"]]){
      teamStats <- stats %>% filter(name == i)
    
      teamStatsSub <- teamStats[["teamStats"]]
    
      wideRanks <- teamStatsSub[[1]][["splits"]][[1]] 
    
      longRanks <- tibble(statName = colnames(wideRanks[, 1:31]), statValue = unlist(wideRanks[1, 1:31]), statRank = unlist(wideRanks[2, 1:31]))
  
      ranks <- cbind(longRanks, wideRanks[1, 32:34], row.names = NULL)
      
      ranks <- cbind(ranks, teamStatsSub[[1]], row.names = NULL) %>% select(-c("splits"))
    
      ranks <- ranks %>% rename("name" = "team.name") 
    
      teamStats <- left_join(ranks, teamStats, by = "name") %>% select(-c("teamStats"))
      
      statsFull <- rbind(statsFull, teamStats)
    } 
    return(statsFull) 
  } 
  
  # MODIFIER
  # team.roster&season
  if(modifier == "team.roster&season"){
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    
    roster <- stats[["roster.roster"]]
    
    for(i in 1:length(roster)){
      roster[[i]]$name <- stats[["name"]][[i]]
    }
    
    roster <- do.call(rbind, roster)
    statsFlatten <- left_join(roster, stats, by = "name") %>% select(-c("roster.roster"))
    return(statsFlatten)
  }
  
  # MODIFIER
  # teamId
  if(modifier == "teamId"){
    stats <- getStatsTable(modifier = modifier, seasonId = seasonId, idNum = idNum) 
    return(stats) 
  }
  
  stop("modifier must be one of: team.roster, person.names, team.schedule.next, team.schedule.previous, team.stats, team.roster&season, teamId")
  
}  

teamStats()
teamStats(modifier = "team.roster")

teamStats(modifier = "team.stats")
teamStats(modifier = "team.roster&season", seasonId = "20182019") 
getStatsTable(modifier = "teamId", idNum = "1,2,3")
```


# Wrapper 

```{r Wrapper}
getNHL <- function(API, recTable = NULL, name = NULL, idNum = NULL, modifier = NULL, seasonId = NULL){
  
  if(!(API %in% c("records", "stats"))){
    return(warning("API must be either records or stats"))
  }
  
  if(API == "records"){
    
    if(recTable == "franchise"){
      tab <- franchise(name = name, idNum = idNum)
      return(tab)
    }
    
    if(recTable == "franchise-team-totals"){
      tab <- teamTotals(name = name, idNum = idNum)
      return(tab)
    }
    
    if(recTable == "franchise-season-records"){
      tab <- season(name = name, idNum = idNum)
      return(tab) 
    }
    
    if(recTable == "franchise-goalie-records"){
      tab <- goalie(name = name, idNum = idNum)
      return(tab) 
    }
    
    if(recTable == "franchise-skater-records"){
      tab <- skater(name = name, idNum = idNum)
      return(tab) 
    }
    
    stop("recTable must be one of: franchise, franchise-team-totals, franchise-season-records, franchise-goalie-records, franchise-skater-records")
  
  }
  
  if(API == "stats"){
   tab <- teamStats(modifier = modifier, seasonId = seasonId, idNum = idNum)
   return(tab)
  }
  
}

getNHL(API = "records", recTable = "franchise")
getNHL(API = "records", recTable = "franchise-team-totals")
getNHL(API = "records", recTable = "franchise-season-records") 
getNHL(API = "records", recTable = "franchise-goalie-records", idNum = 5)
getNHL(API = "records", recTable = "franchise-skater-records", name = "Dallas Stars")

getNHL(API = "stats")
getNHL(API = "stats", modifier = "team.roster")
getNHL(API = "stats", modifier = "person.names")
getNHL(API = "stats", modifier = "team.schedule.next")
getNHL(API = "stats", modifier = "team.schedule.previous")
getNHL(API = "stats", modifier = "team.stats")
getNHL(API = "stats", modifier = "team.roster&season", seasonId = "20192020")
getNHL(API = "stats", modifier = "teamId")

```

# Exploratory Data Anlaysis 

What are the characteristics of a winning team?

```{r}

# Get win perentage 
totals <- getNHL(API = "records", recTable = "franchise-team-totals")
totals
names <- unique(totals[["teamName"]])

winLoss <- tibble()
for(i in names){
  teamTotal <- totals %>% filter(teamName == i) %>% select(c("wins", "losses", "gamesPlayed", "homeTies", "roadTies", "overtimeLosses", "penaltyMinutes", "goalsFor", "goalsAgainst"))

  wins <- 0
  losses <- 0
  gamesPlayed <- 0
  homeTies <- 0 
  roadTies <- 0
  overtimeLosses <- 0 
  penaltyMinutes <- 0
  goalsFor <- 0
  goalsAgainst <- 0
  
  for(j in 1:nrow(teamTotal)){
    wins <- sum(wins, teamTotal[["wins"]][[j]], na.rm = TRUE)
    losses <- sum(losses, teamTotal[["losses"]][[j]], na.rm = TRUE)
    gamesPlayed <- sum(gamesPlayed, teamTotal[["gamesPlayed"]][[j]], na.rm = TRUE)
    homeTies <- sum(homeTies, teamTotal[["homeTies"]][[j]], na.rm = TRUE)
    roadTies <- sum(roadTies, teamTotal[["roadTies"]][[j]], na.rm = TRUE) 
    overtimeLosses <- sum(overtimeLosses, teamTotal[["overtimeLosses"]][[j]], na.rm = TRUE)
    penaltyMinutes <- sum(penaltyMinutes, teamTotal[["penaltyMinutes"]], na.rm = TRUE)
    goalsFor <- sum(goalsFor, teamTotal[["goalsFor"]], na.rm = TRUE)
    goalsAgainst <- sum(goalsAgainst, teamTotal[["goalsAgainst"]], na.rm = TRUE)
  }

 teamWinLoss <- tibble(name = i, wins = wins, losses = losses, homeTies = homeTies, roadTies = roadTies, overtimeLosses = overtimeLosses, gamesPlayed = gamesPlayed, penaltyMinutes = penaltyMinutes, goalsFor = goalsFor, goalsAgainst = goalsAgainst)
 winLoss <- rbind(winLoss, teamWinLoss)
}

winLoss
winLoss <- winLoss %>% mutate(winPct = wins / gamesPlayed, penaltyAvg = penaltyMinutes / gamesPlayed) %>% select("name", "winPct", "penaltyAvg", "gamesPlayed", "goalsFor", "goalsAgainst")
winLoss
```


```{r}
# Win percentage and avg goals per skater 
skaters <- getNHL(API = "records", recTable = "franchise-skater-records")

avgGoals <- skaters %>% group_by(franchiseName) %>% summarize(avgGoals = mean(goals)) %>% rename("name" = "franchiseName")

goalsWins <- left_join(avgGoals, winLoss, by = "name")
goalsWins <- goalsWins %>% filter(gamesPlayed >= 1000)

g <- ggplot(data = goalsWins, aes(x = winPct))
g + geom_point(aes(y = avgGoals)) + geom_smooth(aes(y = avgGoals), method = lm)

```

```{r}

g + geom_point(aes(y = penaltyAvg)) + geom_smooth(aes(y = penaltyAvg), method = lm)
```


Contingency table: division by number of winning teams, conference by number of winning teams
```{r}
getNHL(API = "stats", modifier = "team.stats") %>% filter(statName == c("stat.gamesPlayed", "stat.wins"))
```

```{r}
g2 <- ggplot(data = skaters, aes(x = positionCode))
g2 + geom_bar()
g2 + geom_bar(aes(fill = activePlayer), position = "dodge")
skaters
```

```{r}
GPS <- skaters %>% filter(seasons > 3) %>% mutate(GPS = goals / seasons, PPS = points / seasons)

g3 <- ggplot(data = GPS, aes(x = positionCode)) 

g3 + geom_boxplot(aes(y = GPS))

g3 + geom_boxplot(aes(y = PPS))



```

```{r}
# Win percentage goalies who played at least 10 games 
goalies <- getNHL(API = "records", recTable = "franchise-goalie-records")
goalies <- goalies %>% filter(gamesPlayed > 10) %>% mutate(winPct = wins / gamesPlayed)

ggplot(data = goalies) + geom_histogram(aes(x = winPct), bins = 20)
```

```{r}
streakLength <- function(x){
  if(is.na(x)){
    return(NA)
  }
  
  if(x <= 5){
    return("0-5")
  } else if((x > 5 & x <= 10)){
      return("6-10")
    } else if((x > 10 & x <= 15)){
        return("11-15")
      } else if(x > 15){
          return("greater than 15")
        } else{
            stop("win streak error")
          } 
}

streakLength <- Vectorize(streakLength)

seasonRecs <- getNHL(API = "records", recTable = "franchise-season-records") %>% mutate(winStreakId = streakLength(winStreak))
seasonRecs

goalsCat <- function(x){
  if(x <= .5){
    return("50% or less")
  } else{
      return("Greater than 50%")
    }
}

goalsCat <- Vectorize(goalsCat)

teamRecs <- winLoss %>% rename("franchiseName" = "name")

teamRecs <- teamRecs %>% mutate(goalRatio = goalsFor / ( goalsAgainst + goalsFor)) %>% mutate(goalsId = goalsCat(goalRatio))

tab <- left_join(seasonRecs, teamRecs, by = "franchiseName") %>% select("franchiseName", "winStreakId", "goalsId")

table(tab$winStreakId, tab$goalsId)

```
















```{r}
goalsCategory <- function(x){
  if(is.na(x)){
    return(NA)
  }
  
  if(x <= 100){
    return("0-100")
  } else if((x > 100 & x <= 200)){
      return("101-200")
    } else if((x > 200 & x <= 300)){
        return("201-300")
      } else if((x > 300 & x <= 400)){
          return("301-400")
        } else if((x > 400 & x <= 500)){
            return("401-500")
          } else if(x > 500){
              return("greater than 500") 
            } else{
                stop("goals category error")
              } 
}

goalsCategory <- Vectorize(goalsCategory)

skaters <- skaters %>% mutate(goalsId = goalsCategory(goals))

tab <- left_join(skaters, seasonRecs, by = "franchiseId") %>% select("franchiseId", "goals", "winStreakId", "goalsId")
tab
tab %>% group_by() %>% table()
```














